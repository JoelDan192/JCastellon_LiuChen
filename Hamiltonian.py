import pandas as pd
import numpy as np
import scipy as sp
import networkx as nx #To generate G(n,p) adj matrix

import math
import random
import sys

class HamiltonianWorker(object):
    '''Class in charge of managing states and
    efficient energy calculation.

    Note: colors' index starts at 1. Vertex indices
    start at 0. (see broadcasting)
    '''

    def __init__(self, q=None, n=None, c=None,AdjM=np.array([])):
        if AdjM.size>0:
            adj_matrix = pd.DataFrame(AdjM)
        else:
            adj_matrix = self.__AdjMx_From_Gnp(n,float(c)/n)
        ##Initial Coloring
        self.q=q
        self.X = pd.Series(np.random.randint(low=1,high=q+1,size=adj_matrix.shape[0]))
        #COLORED adj_matrix e.g. A[i,j] = color of j. A[j,i]=color or i
        self.A = adj_matrix.multiply(self.X,axis=1)
        self.n = self.A.shape[0]
        # Get initial energy. Hamiltonian energy function.
        self.SumIdx = self.A.apply(lambda col:col==self.X).sum(axis=1) #Store count of bad edges indexed by vertex
        self.E = int(self.SumIdx.sum())
        if self.E%2 != 0:
            sys.exit('E from colored adj_matrix should be even')

        self.E = self.E/2.0
        # No vertex should have index 0. This is 'null' state and energy.
        self.X_new = np.zeros(self.A.shape[0])
        self.E_new = -1


    def walk(self,T, T_Period):
        '''
        Walks T_period steps the Markov Chain for a fixed temperature parameter.
        @param T: temperature
        @param T_Period: number of steps. This is the epoch for each temperature update.
        @return Energy: last Energy found.
        @return X: last coloring found.
        @return dsc_ratio: descent ratio. e.g. nb of times dE<=0
        @return stct_dsc_ratio: strict descent ratio. e.g. nb of times dE<0
        '''
        assert T>=0.0, 'Temperature parameter must be positive, use bootstrap() method in case of no initial guess.'
        if T==0.0:
            raise ValueError('T has hit 0.0, use bootstrap() method in case of no initial guess.')
        descents, strict_descents = 0,0
        for k in range(T_Period):
            newColor, newEnergy = self.__next_state_and_energy()
            dE = newEnergy - self.E
            if dE > 0.0 and math.exp(-dE/T) >= random.random():
                self.__update(newColor, newEnergy)
            elif dE<=0:
                descents += 1
                if dE < 0.0 :
                    strict_descents +=1
                self.__update(newColor,newEnergy)

        return (self.E, float(descents)/T_Period, float(strict_descents)/T_Period)


    def bootstrap(self):
        '''Call in case no T parameter is guessed '''
        T,steps = 0.0,0
        prevEnergy = self.E
        while T==0.0:
            steps+=1
            newColor,newEnergy = self.__next_state_and_energy()
            self.__update(newColor,newEnergy)
            T = abs(self.E - prevEnergy)
            prevEnergy = self.E
        return T,steps


    def __AdjMx_From_Gnp(self,n,p):

        G_np=nx.fast_gnp_random_graph(n,p) #Undirected graph by default
        adj_matrix = nx.adjacency_matrix(G_np)
        adj_matrix = adj_matrix.toarray()

        if not (adj_matrix.transpose() == adj_matrix).all():
            sys.exit('Non-symmetric adjacency matrix')
        if np.any(adj_matrix.diagonal()):
            sys.exit('No self loops allowed.')

        return pd.DataFrame(adj_matrix)


    def __update(self,X_new, E_new):
        '''update when sampling is accepted'''
        if ((E_new != self.E_new) or (not (X_new==self.X_new).all())):
            sys.exit('New state and energy should have been generated by Hamiltonian on previous step.')

        #Re-Color Matrix
        new_color = X_new.iloc[self.u_idx]
        self.A.iloc[:,self.u_idx][self.A.iloc[:,self.u_idx]!=0] = new_color
        self.X = X_new
        self.E = E_new

        self.X_new = np.zeros(self.n)
        self.E_new = -1
        self.u_idx = -1


    def __next_state_and_energy(self):
        '''calculate next state and its energy
        Both are sent at the same time for efficiency'''

        self.u_idx = np.random.randint(self.n)
        next_X = self.X.copy(deep=True)
        next_X.iloc[self.u_idx] = np.random.choice(np.delete(np.arange(1,self.q+1),next_X.iloc[self.u_idx]-1))
        self.X_new = next_X
        self.E_new = self.__new_energy()
        return (self.X_new, self.E_new)

    def __new_energy(self):
        '''Calculation is done with respect to candidate update.
        Otherwise, hamiltonian energy function can be costly to
        calculate from scratch for large graphs'''
        old_sum = self.E
        sum_old = (self.A.iloc[self.u_idx,:] == self.X.iloc[self.u_idx]).sum()
        sum_update = (self.A.iloc[self.u_idx,:] == self.X_new.iloc[self.u_idx]).sum()
        delta = (sum_update - sum_old)
        return old_sum + delta

    def get_E_from_scratch(self):
        return self.A.apply(lambda col:col==self.X).sum(axis=1).sum()/2.0

